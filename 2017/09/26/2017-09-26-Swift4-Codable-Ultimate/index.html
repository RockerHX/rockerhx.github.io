<!DOCTYPE html>
<html lang="z">
<head>
    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Swift4 终极解析方案：进阶篇 | Andy矢倉</title>
    <meta name="renderer" content="webkit">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="320">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <meta name="description" content="曾梦想 仗贱走天涯 看尽女人和繁华">

    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Swift4 终极解析方案：进阶篇 | Andy矢倉">
    <meta name="twitter:description" content="曾梦想 仗贱走天涯 看尽女人和繁华">

    <meta property="og:type" content="article">
    <meta property="og:title" content="Swift4 终极解析方案：进阶篇 | Andy矢倉">
    <meta property="og:description" content="曾梦想 仗贱走天涯 看尽女人和繁华">

    
    <meta name="author" content="Andy矢倉">
    
    <link rel="stylesheet" href="/css/vno.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css">

    
    <link rel="icon" href="/images/avatar-small.jpg">
    

    <meta name="generator" content="hexo"/>
    

    <link rel="canonical" href="http://rockerhx.github.io/2017/09/26/2017-09-26-Swift4-Codable-Ultimate/"/>

                 
</head>

<body class="home-template no-js">
    <script src="//cdn.bootcss.com/jquery/2.1.4/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <span class="mobile btn-mobile-menu">
        <i class="fa fa-list btn-mobile-menu__icon"></i>
        <i class="fa fa-angle-up btn-mobile-close__icon hidden"></i>
    </span>

    
<header class="panel-cover panel-cover--collapsed" style="background-image: url(/images/background-cover.jpg)">
  <div class="panel-main">
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        <a href="/" title="前往 Andy矢倉 的主页"><img src="/images/avatar.jpg" width="80" alt="Andy矢倉 logo" class="panel-cover__logo logo" /></a>
        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage for Andy矢倉">Andy矢倉</a></h1>
        
        <span class="panel-cover__subtitle panel-subtitle">老板 来杯董小姐 去冰 少糖 多放点小姐</span>
        
        <hr class="panel-cover__divider" />
        <p class="panel-cover__description">曾梦想 仗贱走天涯 看尽女人和繁华</p>
        <hr class="panel-cover__divider panel-cover__divider--secondary" />

        <div class="navigation-wrapper">
          <div>
          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">
              <li class="navigation__item"><a href="/#blog" title="访问博客" class="blog-button">主页</a></li>
            
              <li class="navigation__item"><a href="/archives">所有文章</a></li>
            
            </ul>
          </nav>
          </div>
          <div>
          <nav class="cover-navigation navigation--social">
  <ul class="navigation">

  <!-- Weibo-->
  
  <li class="navigation__item">
    <a href="http://weibo.com/ganmaojijie" title="我的微博" target="_blank">
      <i class='social fa fa-weibo'></i>
      <span class="label">Weibo</span>
    </a>
  </li> 


  <!-- Github -->
  
  <li class="navigation__item">
    <a href="https://github.com/rockerhx" title="查看我的GitHub主页" target="_blank">
      <i class='social fa fa-github'></i>
      <span class="label">Github</span>
    </a>
  </li>


<!-- Stack Overflow -->
        

  <!-- Google Plus -->
  

<!-- Facebook -->

  
<!-- Twitter -->

  <li class="navigation__item">
    <a href="https://twitter.com/rockerhx" title="上Twitter找我" target="_blank">
      <i class='social fa fa-twitter'></i>
      <span class="label">Twitter</span>
    </a>
  </li>

  


  <li class="navigation__item">
    <a href="mailto:rockerhx@gmail.com" title="邮件联系我" target="_blank">
      <i class='social fa fa-envelope'></i>
      <span class="label">Email</span>
    </a>
  </li>


  </ul>
</nav>

          </div>
        </div>

      </div>

    </div>

    <div class="panel-cover--overlay cover-purple"></div>
  </div> 
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner">
            <article class="post-container post-container--single">

  <header class="post-header">
    <div class="post-meta">
      <time datetime="2017-09-26T04:21:11.000Z" class="post-list__meta--date date">9月 26 2017</time> &#8226; <span class="post-meta__tags tags">于 
  <a class="tag-link" href="/tags/Codable/">Codable</a>, <a class="tag-link" href="/tags/JSON/">JSON</a>, <a class="tag-link" href="/tags/Swift4/">Swift4</a>
 </span>
      <span class="page-pv">
       阅读 <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span>
      </span> 
   
    </div>
    <h1 class="post-title">Swift4 终极解析方案：进阶篇</h1>
  </header>

  <section class="post">
    <h2 id="自定义Key"><a href="#自定义Key" class="headerlink" title="自定义Key"></a>自定义Key</h2><p>基础篇里面已经介绍了使用CodingKey协议来处理自定义字段的问题，这里我们反向编码来看一下，示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let json = &quot;&quot;&quot;</span><br><span class="line">&#123;</span><br><span class="line">	&quot;name&quot;: &quot;Endeavor&quot;,</span><br><span class="line">	&quot;abv&quot;: 8.9,</span><br><span class="line">	&quot;brewery&quot;: &quot;Saint Arnold&quot;,</span><br><span class="line">	&quot;style&quot;: &quot;ipa&quot;</span><br><span class="line">&#125;</span><br><span class="line">&quot;&quot;&quot;.data(using: .utf8)! // our data in native (JSON) format</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">struct Beer : Codable &#123;</span><br><span class="line">      // ...</span><br><span class="line">      enum CodingKeys : String, CodingKey &#123;</span><br><span class="line">          case name</span><br><span class="line">          case abv = &quot;alcohol_by_volume&quot;</span><br><span class="line">          case brewery = &quot;brewery_name&quot;</span><br><span class="line">          case style</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>采用编码输出的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let encoder = JSONEncoder()</span><br><span class="line">let data = try! encoder.encode(beer)</span><br><span class="line">print(String(data: data, encoding: .utf8)!)</span><br></pre></td></tr></table></figure>
<p>输出结果为：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"style"</span>:<span class="string">"ipa"</span>,<span class="attr">"name"</span>:<span class="string">"Endeavor"</span>,<span class="attr">"alcohol_by_volume"</span>:<span class="number">8.8999996185302734</span>,<span class="attr">"brewery_name"</span>:<span class="string">"Saint Arnold"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>这样看起来是不是很怪异，因为默认输出风格是<code>.compact</code>，没关系，修改下输出风格为<code>.prettyPrinted</code>就好了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encoder.outputFormatting = .prettyPrinted</span><br></pre></td></tr></table></figure>
<p>最终的编码输出：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"style"</span> : <span class="string">"ipa"</span>,</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Endeavor"</span>,</span><br><span class="line">  <span class="attr">"alcohol_by_volume"</span> : <span class="number">8.8999996185302734</span>,</span><br><span class="line">  <span class="attr">"brewery_name"</span> : <span class="string">"Saint Arnold"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h2><p>OK，我们上一节讲到使用<code>JSONDecoder</code>来编码对象，并输出为JSON，辣么这就来说说时间需要怎么个处理法。<br>JSON里面事并没有表示日期的方式，因此开发的时候都是前后端相互约定好固定的内容进行解析，有可能是以秒数为单位的时间戳，或者是特定格式的日期字符串。通常是<a href="https://en.wikipedia.org/wiki/ISO_8601" target="_blank" rel="noopener">ISO 8601</a>的标准。</p>
<p>以往的情况，前后端约定好之后，我们都是自行解析在转换。辣么现在好了，<code>JSONEncoder</code>会自行帮我们处理，不过默认的方式是<code>.deferToDate</code>酱紫：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct Foo : Encodable &#123;</span><br><span class="line">    let date: Date</span><br><span class="line">&#125;</span><br><span class="line">let foo = Foo(date: Date())</span><br><span class="line">try! encoder.encode(foo)</span><br></pre></td></tr></table></figure>
<p>输出了这鸟样：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"date"</span> : <span class="number">519751611.12542897</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们改成<code>.iso8601</code>试试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">encoder.dateEncodingStrategy = .iso8601</span><br></pre></td></tr></table></figure>
<p>输出这下就对了：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"date"</span> : <span class="string">"2017-06-21T15:29:32Z"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于日期的编码策略，系统提供了如下几种：</p>
<ul>
<li><code>.formatted(DateFormatter)</code>：当您有非标准日期格式字符串时，自行提供DateFormatter实例转换。</li>
<li><code>.custom( (Date, Encoder) throws -&gt; Void )</code>：你需要完全定制的时候，传递一个闭包自行处理时间。</li>
<li><code>.millisecondsSince1970</code>和<code>.secondsSince1970</code>：这种方式其实不是很推荐，因为完全没有办法区分到底是那个时区的时间戳。</li>
</ul>
<blockquote>
<p>解码也是相同的处理方式，详情请看查阅<code>Decoder</code>Api。</p>
</blockquote>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>服务端的<code>Float</code>类型和<code>Swift</code>的浮点数类型是互不兼容的，如果服务端出现<code>NaN</code>、<code>Infinity</code>等这种情况，系统并不会有任何值进行映射。<br>对于这种情况，系统默认是<code>.throw</code>的处理方式，也就是解析不到，那就直接抛出异常。如果我们需要处理这个问题，我们可以提供一个映射：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"a"</span>: <span class="string">"NaN"</span>,</span><br><span class="line">   <span class="attr">"b"</span>: <span class="string">"+Infinity"</span>,</span><br><span class="line">   <span class="attr">"c"</span>: <span class="string">"-Infinity"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">struct Numbers : Decodable &#123;</span><br><span class="line">  let a: Float</span><br><span class="line">  let b: Float</span><br><span class="line">  let c: Float</span><br><span class="line">&#125;</span><br><span class="line">decoder.nonConformingFloatDecodingStrategy =</span><br><span class="line">  .convertFromString(</span><br><span class="line">      positiveInfinity: &quot;+Infinity&quot;,</span><br><span class="line">      negativeInfinity: &quot;-Infinity&quot;,</span><br><span class="line">      nan: &quot;NaN&quot;)</span><br><span class="line"></span><br><span class="line">let numbers = try! decoder.decode(Numbers.self, from: jsonData)</span><br><span class="line">dump(numbers)</span><br></pre></td></tr></table></figure>
<p>输出结果就是：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">▿ __lldb_expr_<span class="number">71</span>.Numbers</span><br><span class="line">  - a: inf</span><br><span class="line">  - b: -inf</span><br><span class="line">  - <span class="keyword">c</span>: nan</span><br></pre></td></tr></table></figure>
<p>对于<code>JSONEncoder</code>，我们可以用<code>nonConformingFloatEncodingStrategy</code>进行反向操作。<br>这在大多数情况下不太可能需要，不保证总有一天它可能会派上用场。</p>
<h2 id="二进制数据"><a href="#二进制数据" class="headerlink" title="二进制数据"></a>二进制数据</h2><p>对于二进制数据，系统会默认采用<code>base64</code>的字符串进行编码，当然也提供自定义方式。</p>
<p><code>JSONEncoder</code>策略：</p>
<ul>
<li>.base64</li>
<li>.custom( (Data, Encoder) throws -&gt; Void)</li>
</ul>
<p><code>JSONDecoder</code>策略：</p>
<ul>
<li>.base64</li>
<li>.custom( (Decoder) throws -&gt; Data)</li>
</ul>
<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><p>在数据解析中，如果有超链接的情况，我们直接提供类型匹配即可。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"title"</span>: <span class="string">"NSDateFormatter - Easy Skeezy Date Formatting..."</span>,</span><br><span class="line">  <span class="attr">"url"</span>: <span class="string">"http://nsdateformatter.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对象结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">struct Webpage : Codable &#123;</span><br><span class="line">  let title: String</span><br><span class="line">  let url: URL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h2><p>有的时候后端会返回一个用key包起来的数组对象：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "beers": [ &#123;...&#125; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接映射即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">struct BeerList : Codable &#123;</span><br><span class="line">    let beers: [Beer]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果返回的数据是顶层，并没有任何key包裹，那就采用基础篇的数组解析方式即可。</p>
<p>再如果，是顶级嵌套，有被包裹，就像这种屌结构：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">"beer"</span> : &#123;</span><br><span class="line">      <span class="attr">"id"</span>: <span class="string">"uuid12459078214"</span>,</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"Endeavor"</span>,</span><br><span class="line">      <span class="attr">"abv"</span>: <span class="number">8.9</span>,</span><br><span class="line">      <span class="attr">"brewery"</span>: <span class="string">"Saint Arnold"</span>,</span><br><span class="line">      <span class="attr">"style"</span>: <span class="string">"ipa"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>那我们就使用大杀器泛型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[String:Beer]]</span><br></pre></td></tr></table></figure>
<p>像这样处理即可：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let decoder = JSONDecoder()</span><br><span class="line">let beers = try decoder.decode([[String:Beer]].self, from: data)</span><br><span class="line">dump(beers)</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">▿ <span class="number">1</span> element</span><br><span class="line">  ▿ <span class="number">1</span> key/value pair</span><br><span class="line">    ▿ (<span class="number">2</span> elements)</span><br><span class="line">      - key: <span class="string">"beer"</span></span><br><span class="line">      ▿ value: __lldb_expr_<span class="number">37</span>.Beer</span><br><span class="line">        - name: <span class="string">"Endeavor"</span></span><br><span class="line">        - brewery: <span class="string">"Saint Arnold"</span></span><br><span class="line">        - abv: <span class="number">8.89999962</span></span><br><span class="line">        - style: __lldb_expr_<span class="number">37</span>.BeerStyle.ipa</span><br></pre></td></tr></table></figure>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>我们来看看如下继承结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person : Codable &#123;</span><br><span class="line">    var name: String?</span><br><span class="line">&#125;</span><br><span class="line">class Employee : Person &#123;</span><br><span class="line">    var employeeID: String?</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尝试下编码会发生什么情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let employee = Employee()</span><br><span class="line">employee.employeeID = &quot;emp123&quot;</span><br><span class="line">employee.name = &quot;Joe&quot;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let encoder = JSONEncoder()</span><br><span class="line">encoder.outputFormatting = .prettyPrinted</span><br><span class="line">let data = try! encoder.encode(employee)</span><br><span class="line">print(String(data: data, encoding: .utf8)!)</span><br></pre></td></tr></table></figure>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"Joe"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>事实上，对象继承并不能如我们所愿可以直接编码解码，所以还是得处理下自定义编码解码方法：</p>
<figure class="highlight plain"><figcaption><span>Person : Codable &#123;</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    var name: String?</span><br><span class="line"></span><br><span class="line">    private enum CodingKeys : String, CodingKey &#123;</span><br><span class="line">        case name</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func encode(to encoder: Encoder) throws &#123;</span><br><span class="line">        var container = encoder.container(keyedBy: CodingKeys.self)</span><br><span class="line">        try container.encode(name, forKey: .name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类也使用相同的处理方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Employee : Person &#123;</span><br><span class="line">    var employeeID: String?</span><br><span class="line"></span><br><span class="line">    private enum CodingKeys : String, CodingKey &#123;</span><br><span class="line">        case employeeID = &quot;emp_id&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override func encode(to encoder: Encoder) throws &#123;</span><br><span class="line">    	try super.encode(to: encoder)</span><br><span class="line">        var container = encoder.container(keyedBy: CodingKeys.self)</span><br><span class="line">        try container.encode(employeeID, forKey: .employeeID)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正确结果：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"name"</span>: <span class="string">"Joe"</span>,</span><br><span class="line">    <span class="attr">"emp_id"</span>: <span class="string">"emp123"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>相信两篇教程里面的示例已经能满足日常开发95%的需求了，如果你们的后端非要奇葩到那5%，那你就自求多福，自己去啃文档，妈宝是当不完的，白白。</p>

  </section>

</article>

<section class="read-more">
           
    
               
            <div class="read-more-item">
                <span class="read-more-item-dim">最近的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/11/20/2017-11-20-RxSwift-Begining-1-Introduction/" title="RxSwift从零入手 - 介绍">RxSwift从零入手 - 介绍</a></h2>
                <p class="excerpt">
                
                
译自：Introducing RxSwift: Reactive Programming with Swift!

简介
“If you’ve ever used an asynchronous callback based API, you’ve probably dealt with hand
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-11-20T09:17:48.000Z" class="post-list__meta--date date">11月 20 2017</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/RxSwift/">RxSwift</a>, <a class="tag-link" href="/tags/Swift4/">Swift4</a>
</span><a class="btn-border-small" href="/2017/11/20/2017-11-20-RxSwift-Begining-1-Introduction/">继续阅读</a></div>
                           
            </div>
        
        
               
            <div class="read-more-item">
                <span class="read-more-item-dim">更早的文章</span>
                <h2 class="post-list__post-title post-title"><a href="/2017/09/25/2017-09-25-Swift4-Codable-Basic/" title="Swift4 终极解析方案：基础篇">Swift4 终极解析方案：基础篇</a></h2>
                <p class="excerpt">
                
                
做过网络开发，特别是互联网，甚至移动端开发的，日常对于数据解析，早年主流的XML，现今主流的JSON都是非常熟悉的，说道解析，系统自带和各种第三方的解析库，除了解析当然也当不了懒癌的脚步，各种model反射库。对于Objective-C各种方案都尤为成熟，甚至还有专门的MacApp用于model生
                &hellip;
                </p>
                <div class="post-list__meta"><time datetime="2017-09-24T17:57:11.000Z" class="post-list__meta--date date">9月 25 2017</time> &#8226; <span class="post-list__meta--tags tags">于 
  <a class="tag-link" href="/tags/Codable/">Codable</a>, <a class="tag-link" href="/tags/JSON/">JSON</a>, <a class="tag-link" href="/tags/Swift4/">Swift4</a>
</span><a class="btn-border-small" href="/2017/09/25/2017-09-25-Swift4-Codable-Basic/">继续阅读</a></div>
                       
            </div>
        
     
   
   
  
</section>

            <footer class="footer">
    <span class="footer__copyright">
        &copy; 2018 Andy矢倉 - 本站点采用 <a href="http://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a>
       
    </span>
    <span class="footer__copyright">
             - 基于 <a href="http://hexo.io">Hexo</a> 搭建，使用 <a href="https://github.com/monniya/hexo-theme-new-vno ">new-vno</a> 主题，由<a href="https://monniya.com ">@Monniya</a> 修改自 <a href="https://github.com/lenbo-ma/hexo-theme-vno" target="_blank">Vno</a>, 原创出自<a href="http://github.com/onevcat/vno" target="_blank">onevcat</a>
         </span>
       
    
    
</footer>


        </div>
    </div>

     
    
    <script>
        var _hmt = _hmt || [];
        (function() {
            var hm = document.createElement("script");
            hm.src = "//hm.baidu.com/hm.js?f1811f144f64379f918cf1ef7bf3f3cb";
            var s = document.getElementsByTagName("script")[0]; 
            s.parentNode.insertBefore(hm, s);
        })();
    </script>



    <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    
</body>
</html>
