<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>AudioKit 入门教程 | Andy矢倉</title><meta name="keywords" content="Audio,AudioKit,Swift4+,Xcode9+"><meta name="author" content="Andy矢倉,rockerhx@gmail.com"><meta name="copyright" content="Andy矢倉"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><meta name="description" content="原文：AudioKit Tutorial: Getting Started作者：Colin Eberhardt同时感谢：kmyhy    近来手上有一些音频相关的开发工作，搜搜基Hub，目前最为强大，性能屌爆，编码炫酷的开源库也只有AudioKit了。Raywenderlich也能找到相关教程，介于作者是3.0+的教程，很多代码都不能跑了，特此整理一趴。本文不仅是一篇iOS开发教程，更是一篇精彩">
<meta property="og:type" content="article">
<meta property="og:title" content="AudioKit 入门教程">
<meta property="og:url" content="http://rockerhx.github.io/2018/07/03/2018-07-03-AudioKit-Tutorial-Getting-Started/index.html">
<meta property="og:site_name" content="Andy矢倉">
<meta property="og:description" content="原文：AudioKit Tutorial: Getting Started作者：Colin Eberhardt同时感谢：kmyhy    近来手上有一些音频相关的开发工作，搜搜基Hub，目前最为强大，性能屌爆，编码炫酷的开源库也只有AudioKit了。Raywenderlich也能找到相关教程，介于作者是3.0+的教程，很多代码都不能跑了，特此整理一趴。本文不仅是一篇iOS开发教程，更是一篇精彩">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80">
<meta property="article:published_time" content="2018-07-03T15:01:11.000Z">
<meta property="article:modified_time" content="2021-01-01T10:33:54.562Z">
<meta property="article:author" content="Andy矢倉">
<meta property="article:tag" content="Audio">
<meta property="article:tag" content="AudioKit">
<meta property="article:tag" content="Swift4+">
<meta property="article:tag" content="Xcode9+">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80"><link rel="shortcut icon" href="https://tva3.sinaimg.cn/crop.0.0.399.399.180/5c5c87d8gw1egzy35lsj1j20b40b40tg.jpg"><link rel="canonical" href="http://rockerhx.github.io/2018/07/03/2018-07-03-AudioKit-Tutorial-Getting-Started/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
};

var saveToLocal = {
  set: function setWithExpiry(key, value, ttl) {
    const now = new Date()
    const expiryDay = ttl * 86400000
    const item = {
      value: value,
      expiry: now.getTime() + expiryDay,
    }
    localStorage.setItem(key, JSON.stringify(item))
  },

  get: function getWithExpiry(key) {
    const itemStr = localStorage.getItem(key)

    if (!itemStr) {
      return undefined
    }
    const item = JSON.parse(itemStr)
    const now = new Date()

    if (now.getTime() > item.expiry) {
      localStorage.removeItem(key)
      return undefined
    }
    return item.value
  }
}

// https://stackoverflow.com/questions/16839698/jquery-getscript-alternative-in-native-javascript
const getScript = url => new Promise((resolve, reject) => {
  const script = document.createElement('script')
  script.src = url
  script.async = true
  script.onerror = reject
  script.onload = script.onreadystatechange = function() {
    const loadState = this.readyState
    if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
    script.onload = script.onreadystatechange = null
    resolve()
  }
  document.head.appendChild(script)
})</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '1月 1 2021 18:33:54'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(function () {  window.activateDarkMode = function () {
    document.documentElement.setAttribute('data-theme', 'dark')
    if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
    }
  }
  window.activateLightMode = function () {
    document.documentElement.setAttribute('data-theme', 'light')
   if (document.querySelector('meta[name="theme-color"]') !== null) {
      document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
    }
  }
  const autoChangeMode = 'true'
  const t = saveToLocal.get('theme')
  if (autoChangeMode === '1') {
    const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
    const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
    const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
    const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified
    if (t === undefined) {
      if (isLightMode) activateLightMode()
      else if (isDarkMode) activateDarkMode()
      else if (isNotSpecified || hasNoSupport) {
        const now = new Date()
        const hour = now.getHours()
        const isNight = hour <= 6 || hour >= 18
        isNight ? activateDarkMode() : activateLightMode()
      }
      window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
        if (saveToLocal.get('theme') === undefined) {
          e.matches ? activateDarkMode() : activateLightMode()
        }
      })
    } else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else if (autoChangeMode === '2') {
    const now = new Date()
    const hour = now.getHours()
    const isNight = hour <= 6 || hour >= 18
    if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
    else if (t === 'light') activateLightMode()
    else activateDarkMode()
  } else {
    if (t === 'dark') activateDarkMode()
    else if (t === 'light') activateLightMode()
  }const asideStatus = saveToLocal.get('aside-status')
if (asideStatus !== undefined) {
   if (asideStatus === 'hide') {
     document.documentElement.classList.add('hide-aside')
   } else {
     document.documentElement.classList.remove('hide-aside')
   }
}})()</script><meta name="generator" content="Hexo 5.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src="https://ww1.sinaimg.cn/large/5c5c87d8gw1egzy35lsj1j20b40b40tg.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(http://localhost:4000/images/2018-07-03-AudioKit-Tutorial-Getting-Started/01.AudioKit-feature.png)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Andy矢倉</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 娱乐</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">AudioKit 入门教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2018-07-03T15:01:11.000Z" title="发表于 7月 3 2018 23:01:11">7月 3 2018</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-01-01T10:33:54.562Z" title="更新于 1月 1 2021 18:33:54">1月 1 2021</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Audio/">Audio</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Audio/Tutorial/">Tutorial</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://www.raywenderlich.com/145770/audiokit-tutorial-getting-started">AudioKit Tutorial: Getting Started</a><br>作者：<a target="_blank" rel="noopener" href="https://www.raywenderlich.com/u/colineberhardt">Colin Eberhardt</a><br>同时感谢：<a target="_blank" rel="noopener" href="http://blog.csdn.com/kmyhy">kmyhy</a></p>
</blockquote>
<hr>
<blockquote>
<p>近来手上有一些音频相关的开发工作，搜搜<a target="_blank" rel="noopener" href="https://github.com/">基Hub</a>，目前最为强大，性能屌爆，编码炫酷的开源库也只有<a target="_blank" rel="noopener" href="https://audiokit.io/">AudioKit</a>了。<code>Raywenderlich</code>也能找到相关教程，介于作者是3.0+的教程，很多代码都不能跑了，特此整理一趴。<br>本文不仅是一篇iOS开发教程，更是一篇精彩的科普文。关于编程与艺术的结合，声学物理与音乐的碰撞，尽在此文。推荐所有程序员都好好读一读它，让我们的生活除了代码，还有艺术，还有音乐。感谢作者<a target="_blank" rel="noopener" href="https://www.raywenderlich.com/u/colineberhardt">Colin Eberhardt</a>。</p>
</blockquote>
<p>iOS 设备提供了丰富的多媒体体验，比如绚丽的视觉效果、声音和可触摸的交互界面。尽管能够使用各种各样的特性，但作为开发者，我们更多地关注了应用的视觉设计，而忽略了用户体验的声学效果。</p>
<p><code>AudioKit</code>是一个高级音频框架，由声学设计师、程序员和音乐家为 iOS 专门打造。AudioKit底层混合了<code>Swift</code>、<code>Objective-C</code>、<code>C++</code>和<code>C</code>，负责和苹果音频已硬件的Api打交道。所有神奇（同时十分复杂的）技术都封装成为极其友好的 Swift Api ，你甚至可以直接在<code>Xcode</code>的<code>Playground</code>中使用它。</p>
<p>本文无法全面覆盖 AudioKit 的知识点。相反，我们会通过介绍声音合成和计算机声频的历史，来带你进行一次有趣和时尚的 AudioKit 之旅。通过这种方式，你会学到基本的声学物理，了解早期的合成器比如电子琴是如何工作的。最终来到现代，一个大混音时代。</p>
<p>请给自己来一杯咖啡，拖过一张椅子，开始我们的旅程！</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/01.AudioKit-feature.png" align="center" width="30%" height="30%" />


<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><blockquote>
<p>原教程的原始内容使用的是 3.4.0 版本，用的是Playground做案例，本文使用最新的 4.3.0 ，用Xcode创建的Swift项目做案例。</p>
</blockquote>
<p>港真，教程的第一步并不是特别鸡冻的。为了在 Playground 中使用 AudioKit，我们必须提前进行一些准备工作。</p>
<p>我们需要先到<a target="_blank" rel="noopener" href="https://github.com/AudioKit/AudioKit">AudioKit</a>下源码<a target="_blank" rel="noopener" href="https://github.com/AudioKit/AudioKit/archive/v4.3.zip">AudioKit-4.3</a>，或者自行clone：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/AudioKit/AudioKit.git</span><br></pre></td></tr></table></figure>
<p>解压好后用<code>Terminal</code>进入<code>AudioKit-4.3</code>文件夹执行编译命令：</p>
<figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> Frameworks</span><br><span class="line">$ ./build_frameworks.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<p>编译时间较长（14的顶配编译的近十分钟吧），你阔以继续阅读，或者撸一把，或者鸡一把。</p>
</blockquote>
<p>一定要编译完成，编译好后进入<code>Playgrounds</code>文件，打开下面的<code>AudioKitPlaygrounds.xcodeproj</code>，这里我们就阔以看官方为我们写好的示例代码，提前体验一把 AudioKit 的强大。体验完了别忘了纸巾，进入正题开始教程之旅。</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/02.StartProject.png" align="center" width="80%" height="80%" />

<p>新建一个名为<code>Jornery</code>的<code>Playground</code>。录入一下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let oscillator &#x3D; AKOscillator()</span><br><span class="line"></span><br><span class="line">AudioKit.output &#x3D; oscillator</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">oscillator.start()</span><br><span class="line"></span><br><span class="line">sleep(10)</span><br></pre></td></tr></table></figure>
<p>编译时，你会听到大约 10 秒钟的蜂鸣声。你可以点击 Playground 调试窗口左下角的 Play/Stop 按钮停止或运行 Playground。</p>
<blockquote>
<p>注意：建议打开工程的时候就直接<code>Command + B</code>编译一遍，再跑想看的代码。如果 Playground 执行出错，并在 Debug 窗口中出现错误，你可以重启 Xcode。不幸的是，当 Playground 和框架一起使用时，总是容易出现一些小问题，并且无法预知。<br>另外建议把 Run 方式改为 <code>Manually Run</code>，<code>Automatically Run</code>太容易故障了。</p>
</blockquote>
<h2 id="振荡器和声学基础"><a href="#振荡器和声学基础" class="headerlink" title="振荡器和声学基础"></a>振荡器和声学基础</h2><p>人类通过物体制造音乐——通过击打、拖拉或者弹奏等形式——有数千年的历史。我们的许多民族乐器，比如鼓、吉他，已经发明几个世纪了。电子乐器的第一个次使用记录，或者是第一次通过电路发声，是 1874 年 Elisha Gray 创下的，他从事电信行业。Elisha 发明了振荡器，最原始的声音合成装置，你的探索将从这个东西开始。</p>
<p>右键点击 Playground，选择 New Playground Page，创建一个新的 Playground 文件 <code>Oscillators</code>。</p>
<p>将 Xcode 产生的代码替换为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 1. Create an oscillator</span><br><span class="line">let oscillator &#x3D; AKOscillator()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. Start the AudioKit &#39;engine&#39;</span><br><span class="line">AudioKit.output &#x3D; oscillator</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. Start the oscillator</span><br><span class="line">oscillator.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br></pre></td></tr></table></figure>
<p>这个 Playground 将没完没了地发出哔哔声——呃，有意思。你可以按 Stop 来停止它。<br>这和前面创建的测试 Playground 差不多，但这次我们将深入讨论细节。<br>代码分成了几个步骤：</p>
<ul>
<li>创建一个 AudioKit 振荡器，它是一个 AKNode 子类。节点是构成你的音频序列的主要元素。</li>
<li>将 AudioKit 引擎和你最终输出的节点关联起来，在这里这个节点是你唯一的节点。音频引擎就像物理引擎或游戏引擎：你必须启动它并让它持续运转，这样你的音频序列才能被执行。</li>
<li>最后，打开振荡器，它会发出一条声波。</li>
</ul>
<p>一个振荡器会创建一个重复的、或者周期性的无限延续的信号。在这个 Playground 中，AKOscillator 发出了一个正弦波。这个数字化的正弦波经过 AudioKit 处理，直接输出到你的扬声器或者耳麦，导致真正的振荡器以同样的正弦波进行振荡。声音通过压缩你耳朵周围的空气传播到你耳中，最终你就听到了这个烦人的啸叫声！</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/03.SineWave.png" align="center"/>

<p>有两个参数决定了振荡器发出的声音是什么样子：amplitude - 振幅，它是正弦波的高度并决定声音的大小，以及 frequency - 频率，它决定了音高。<br>在你的 Playground 中，在创建振荡器之后加入这两句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">oscillator.frequency &#x3D; 300</span><br><span class="line">oscillator.amplitude &#x3D; 0.5</span><br></pre></td></tr></table></figure>
<p>倾听一会，你会发现现在的音量只是刚才的一半，而且音高也比刚才低了。频率单位为赫兹（即每秒周期数），决定了音符的音高。而振幅，范围从 0-1 ，决定了音量。<br>Elisha Gray 在专利官司中输给了Alexander Graham Bell，失去了成为电话机发明者的机会。但是，他的偶然发明振荡器却导致第一个电子乐器专利的产生。</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/04.GrayPatent.png" align="center" />

<p>许多年以后，Léon Theremin 发明了一个怪异的电子乐器，至今仍然被使用着。使用特雷门琴，你可以在这个乐器上方挥舞手臂来改变电子振荡器的频率。如果你不知道怎么形容这个乐器发出的声音，我建议你听一听 The Beach Boys 演唱的 Good Vibrations, 这首歌曲中特雷门琴所发出的独特声音令人记忆深刻。</p>
<p>你可以在 Playground 的最后加入以下代码模拟这种效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">oscillator.rampDuration &#x3D; 0.2</span><br><span class="line">oscillator.frequency &#x3D; 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import AudioKitUI</span><br><span class="line"></span><br><span class="line">AKPlaygroundLoop(every: 0.5) &#123;</span><br><span class="line">    oscillator.frequency &#x3D; (oscillator.frequency &#x3D;&#x3D; 500 ? 100 : 500)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>rampDuration 属性允许振荡器在属性值之间平滑过渡（比如频率或振幅）。AKPlaygroundLoop 是一个很有用的实用函数，允许周期性地执行 Playground 中的代码。在这里，你简单滴每 0.5 秒就切换一次振荡器的频率，从 500Hz 到 100 Hz。</p>
<p>你制造了自己的特雷门琴！</p>
<p>简单的振荡器可以发出音符，但是并不能令耳朵愉悦。真正的乐器还受许多别的因素的影响，比如钢琴，它的声音很独特。在后面几节中，你会继续探索它们是如何形成的。<br>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let oscillator &#x3D; AKOscillator()</span><br><span class="line">oscillator.frequency &#x3D; 300</span><br><span class="line">oscillator.amplitude &#x3D; 0.5</span><br><span class="line"></span><br><span class="line">AudioKit.output &#x3D; oscillator</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">oscillator.start()</span><br><span class="line"></span><br><span class="line">oscillator.rampDuration &#x3D; 0.2</span><br><span class="line">oscillator.frequency &#x3D; 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import AudioKitUI</span><br><span class="line"></span><br><span class="line">AKPlaygroundLoop(every: 0.5) &#123;</span><br><span class="line">    oscillator.frequency &#x3D; (oscillator.frequency &#x3D;&#x3D; 500 ? 100 : 500)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br></pre></td></tr></table></figure>

<h2 id="声音封包"><a href="#声音封包" class="headerlink" title="声音封包"></a>声音封包</h2><p>当乐器演奏出一个音符时，振幅（或音量）是会变化的，并且每个乐器都不相同。有一个能够模拟这个效果的模型，叫做 Attack-Decay-Sustain-Release (ADSR) 封包: </p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/05.ADSR.png" align="center" />

<p>这个封包由几个部分构成：</p>
<ul>
<li>Attack  - 上行: 在这个阶段声音上行至最大音量。</li>
<li>Decay   - 下行: 这个时候声音下滑到 Sustain 水平。</li>
<li>Sustain - 维持: 这个阶段声音会维持在释放终止时的音量，一直到开始 Release。</li>
<li>Release - 释放: 这个阶段音量开始下滑到 0。</li>
</ul>
<p>一台钢琴，当琴弦被木锤敲击，会发出一个非常短促的上行音然后迅速下降。一把小提琴则会发出比较长的上行、下行和维持，因为演奏时琴弓不会离开琴弦。<br>电子琴是第一批电子乐器中使用 ADSR 封包的乐器之一。这种乐器发明于 1939 年，由 163 个电子管和 1000 多个特制的电容器构成，重达 500 英磅（230 kg)。但不幸的是，只制造了 1000 台电子琴，它没有获得商业上的成功。</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/06.Novachord_frontS.jpg" align="center" />
图片来自于 [courtesy of Hollow Sun](https://en.wikipedia.org/wiki/File:Novachord_frontS.jpg) – 遵循 CC attribution 协议。

<p>
右键单击 Playground 中的顶层元素，Journey，选择 New Playground Page ，创建一个新的 Playground 叫做`ADSR`。编辑文件内容为：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let oscillator &#x3D; AKOscillator()</span><br></pre></td></tr></table></figure>
创建了一个振荡器，这个你已经很熟悉了。然后继续加入代码：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let envelope &#x3D; AKAmplitudeEnvelope(oscillator)</span><br><span class="line">envelope.attackDuration &#x3D; 0.01</span><br><span class="line">envelope.decayDuration &#x3D; 0.1</span><br><span class="line">envelope.sustainLevel &#x3D; 0.1</span><br><span class="line">envelope.releaseDuration &#x3D; 0.3</span><br></pre></td></tr></table></figure>
这次创建了一个 AKAmplitudeEnvelope 并定义了一个 ADSR 封包。durantion 参数用秒为单位指定，level 参数指定的是音量，取值访问 0-1 之间。
AKAmplitudeEnvelope 是 AKNode 子类，同 AKOscillator 一样。在上面的代码中，你可以看到，振荡器作为参数被传递给了封包的构造函数，两个节点连在了一起。
接着：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AudioKit.output &#x3D; envelope</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">oscillator.start()</span><br></pre></td></tr></table></figure>
AudioKit 引擎启动，这次将输出改成 ADSR 封包，然后打开振荡器。

<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/07.ADSRNode.png" align="center" />

<p>为了听到封包效果，你必须重复播放封包，然后停止封包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitUI</span><br><span class="line"></span><br><span class="line">AKPlaygroundLoop(every: 0.5) &#123;</span><br><span class="line">    if (envelope.isStarted) &#123;</span><br><span class="line">        envelope.stop()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        envelope.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br></pre></td></tr></table></figure>
<p>现在你会听到同一个音符被反复播放，但这次带上了声音封包效果，听起来有点钢琴的味道了。<br>每秒播放两次，每个循环都以 ADSR 开始和结束。当循环开始后，快速上行到最大音量，这个过程大约 0.01 秒，紧接着是 0.1 秒的下行，到达维持水平。这个过程约 0.5 秒，然后释放 0.3 秒。<br>修改 ADSR 值，尝试创建其他声音的效果。试试如何模拟小提琴？<br>从振荡器发出正弦波开始到现在，已经过去很长时间了。当你用振荡器演奏音符的同时，会使用 ADSR 去让声音更加柔和，但你仍然不能把它称之为真正的音乐！<br>下一节，你会学习如何创建更加丰富的声音。<br>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let oscillator &#x3D; AKOscillator()</span><br><span class="line"></span><br><span class="line">let envelope &#x3D; AKAmplitudeEnvelope(oscillator)</span><br><span class="line">envelope.attackDuration &#x3D; 0.01</span><br><span class="line">envelope.decayDuration &#x3D; 0.1</span><br><span class="line">envelope.sustainLevel &#x3D; 0.1</span><br><span class="line">envelope.releaseDuration &#x3D; 0.3</span><br><span class="line"></span><br><span class="line">AudioKit.output &#x3D; envelope</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">oscillator.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import AudioKitUI</span><br><span class="line"></span><br><span class="line">AKPlaygroundLoop(every: 0.5) &#123;</span><br><span class="line">    if (envelope.isStarted) &#123;</span><br><span class="line">        envelope.stop()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        envelope.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br></pre></td></tr></table></figure>

<h2 id="声音叠加合成"><a href="#声音叠加合成" class="headerlink" title="声音叠加合成"></a>声音叠加合成</h2><p>每种乐器都有独一无二的音质，并以其音色而得名。这就是为什么钢琴的声音和小提琴的声音截然不同的原因，哪怕它们演奏同一个音符。音色的一个重要属性是乐器所产生的声谱。声谱表示乐器发出一个单音符时所组成的频率范围。你的 Playground 当前所用的振荡器只能发出单一的频率，所以听起来非常假。<br>通过将一系列振荡器合并在一起作为输出并演奏同一个音符，你能够真实地模拟出一个乐器。这就是“叠加合成”。这是你的下一个课题。</p>
<p>右键单击 Playground,选择 New Playground Page 创建新的页，叫做<code>Additive Synthesis</code>，编辑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line">func createAndStartOscillator(frequency: Double) -&gt; AKOscillator &#123;</span><br><span class="line">    let oscillator &#x3D; AKOscillator()</span><br><span class="line">    oscillator.frequency &#x3D; frequency</span><br><span class="line">    return oscillator</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于叠加合成，你需要使用多个振荡器。createAndStartOscillator 方法用于创建它们。<br>然后写入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let frequencies &#x3D; (1...5).map &#123; $0 * 261.63 &#125;</span><br></pre></td></tr></table></figure>
<p>这里用了一个 Range 操作来创建一个从 1 到 5 的序列。然后对这个序列进行 map 操作，将每个数字乘以 261.63。这个数字是标注键盘上的中音 C 的音频。将其他数字乘以这个值，这就是“和声”。</p>
<p>然后继续加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let oscillators &#x3D; frequencies.map &#123;</span><br><span class="line">    createAndStartOscillator(frequency: $0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次进行一个 map 操作，以创建多个振荡器。<br>然后将它们合成在一起。加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mixer &#x3D; AKMixer()</span><br><span class="line">oscillators.forEach &#123; mixer.connect(input: $0) &#125;</span><br></pre></td></tr></table></figure>
<p>AKMixer 类也是 AudioKit 中的节点；<br>它将 1 个或多个节点作为输出并将它们合成在一起。<br>然后：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">let envelope &#x3D; AKAmplitudeEnvelope(mixer)</span><br><span class="line">envelope.attackDuration &#x3D; 0.01</span><br><span class="line">envelope.decayDuration &#x3D; 0.1</span><br><span class="line">envelope.sustainLevel &#x3D; 0.1</span><br><span class="line">envelope.releaseDuration &#x3D; 0.3</span><br><span class="line"></span><br><span class="line">AudioKit.output &#x3D; envelope</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">oscillators.map &#123; $0.start() &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import AudioKitUI</span><br><span class="line"></span><br><span class="line">AKPlaygroundLoop(every: 0.5) &#123;</span><br><span class="line">    if (envelope.isStarted) &#123;</span><br><span class="line">        envelope.stop()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        envelope.start()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码你已经很熟悉了；它用 mixer 创建了一个 ADSR 封包，将它提供给 AudioKit 引擎，然后不停地播放和停止它。<br>要真正能够听出合成的效果，你可以尝试一下将这些频率进行不同的组合。当你尝试这样做的时候，Playground 的 live-view 是一个不错的工具！<br>加入下列代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class LiveView: AKLiveViewController &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        addTitle(&quot;Mixer&quot;)</span><br><span class="line"></span><br><span class="line">        oscillators.forEach &#123; oscillator in</span><br><span class="line">            let slider &#x3D; AKSlider(property: &quot;\(oscillator.frequency) Hz&quot;, value: oscillator.amplitude) &#123; amplitude in</span><br><span class="line">                oscillator.amplitude &#x3D; amplitude</span><br><span class="line">            &#125;</span><br><span class="line">            addView(slider)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br><span class="line">PlaygroundPage.current.liveView &#x3D; LiveView()</span><br></pre></td></tr></table></figure>
<p>AudioKit 有许多类允许你轻松创建交互式的 Playground；我们在这里也使用了其中几个。<br>LiveView 类是 AKLiveViewController 的子类，它由一系列垂直排列的 subview 组成。在 viewDidLoad 方法中，你遍历每个振荡器，为每个振荡器创建一个 AKSlider。每个 Slider 用每个振荡器的频率和振幅进行初始化，当遍历到一个 slider 时，都可以为它设置一个回调块，这样当你拖动 slider 时回调块被执行。尾随闭包就是这个回调块，允许你修改每个振荡器的频率。通过这种简单的方式，你可以和 Playground 进行交互。</p>
<p>为了测试上述代码，你必须开启 live view。点击右上角的双环图标，打开助手窗口。同时将 live view 设置为正确的 playground 文件。</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/08.AdditiveSynth.png" align="center" width="80%" height="80%"/>

<p>你可以通过修改每个 Slider 的振幅来改变乐器的音色。为了获得更加自然的音质，我建议你参照上图来进行设置。</p>
<p>最早的一种采用叠加合成的合成器是 200 吨重的电传簧风琴。如此巨大的体量，立即宣告了这种乐器的消亡。结局更好的电子管风琴使用了类似的转速脉冲轮技术，但体积更小，用同样的加法合成实现了独特的声音。电传簧风琴在 1935 年发明，在前卫摇滚时代仍然是一种广为人知的流行乐器。</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/09.Hammond_c3_Emilio_Munoz.jpg" align="center" />

<p>C3 电传簧风琴 – 图片来自 <a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Hammond_c3_Emilio_Mu%C3%B1oz.jpg">public domain image</a>。</p>
<p>
转速脉冲轮上有旋转的轮盘，轮沿上有许多光滑的隆起，旋转轮盘附近有一个拾波器总成。电传簧风琴由许多这样的转速脉冲轮组成，它们以不同的速度旋转。音乐家通过拉杆来混合这些声音并产生一个音符。这种发声方式真的十分简陋，严格地讲，与其说是电子式的，不如说是机电式的。

<p>要创建更真实的声谱有许多别的技术，比如 调频技术（FM）和脉宽调制技术（PWM），这两种在 AudioKit 中都可以通过<code>AKFMOscillator</code>和<code>AKPWMOscillator</code>类来实现。无疑，我将鼓励你去尝试这两者。为什么不在你的 Playground 中用这两者将 AKOscillator 替换掉呢？</p>
<h2 id="复音"><a href="#复音" class="headerlink" title="复音"></a>复音</h2><p>上个世纪 70 年代，出现了一种偏离模块化合成的理论，它使用单独的振荡器、封包和过滤器，并使用了微处理器。替代模拟电路，它使用了数字合成的方式发声。它导致了价格极其低廉和便携式合成器的出现，比如著名的雅马哈电子合成器，被专业和业余音乐爱好者广泛使用。</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/10.Yamaha_DX7_Table.jpg" align="center" />

<p>1983 年的 Yamaha DX7 – 图片来自<a target="_blank" rel="noopener" href="https://commons.wikimedia.org/wiki/File:Yamaha_DX7_Table_4.JPG">public domain image</a></p>
<p>
你所有的 Playground 都被死死限制在只能一次演奏一个音符。如果使用多个乐器，音乐家可以同时演奏多个音符。这种演奏方式就叫做“复音”，相反，如果一次只能演奏一个音符，就像你的 Playground 一样，则叫做“单音”。
为了制造复音，你需要创建多个振荡器，每个振荡器演奏不同的音符，并通过一个 mixer 节点播放出来。但是，我们还有一种更简单的 方法：使用 AudioKit 的振荡器 bank。

<p>右键单击 Playground，选择 New Playground Page 创建一个新的 page 就叫做<code>Polyphony</code>。写入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line">let bank &#x3D; AKOscillatorBank()</span><br><span class="line">AudioKit.output &#x3D; bank</span><br><span class="line">try? AudioKit.start()</span><br></pre></td></tr></table></figure>
<p>这里创建了一个振荡器 bank，并将它作为 AudioKit 的输出。如果你按下 Command 键点击 AKOscilatorBank，你将看到它的类定义，你会发现它其实继承了 AKPolyphonicNode。如果你继续深究下去，你会发现它又继承了 AKNode 并采用了AKPolyphonic 协议。</p>
<p>因此，振荡器 bank 和其他 AudioKit 一样，它的输出也能够被 mixer、封包和其它滤镜和效果所加工。AKPolyphonic 协议描述了你应该如何在这个复音节点上演奏音符，等下你就知道了。</p>
<p>为了测试这个振荡器，你需要设法和谐地播放多个音符。这听起来好复杂？<br>在 Playground 后面加入下列代码，同时打开 live view:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitUI</span><br><span class="line"></span><br><span class="line">class LiveView: AKLiveViewController, AKKeyboardDelegate &#123;</span><br><span class="line"></span><br><span class="line">    override func viewDidLoad() &#123;</span><br><span class="line">        addTitle(&quot;Keyboard&quot;)</span><br><span class="line">        let keyboard &#x3D; AKKeyboardView(width: 440, height: 100)</span><br><span class="line">        keyboard.delegate &#x3D; self</span><br><span class="line">        keyboard.polyphonicMode &#x3D; true</span><br><span class="line">        addView(keyboard)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func noteOn(note: MIDINoteNumber) &#123;</span><br><span class="line">        bank.play(noteNumber: note, velocity: 80)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    func noteOff(note: MIDINoteNumber) &#123;</span><br><span class="line">        bank.stop(noteNumber: note)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br><span class="line">PlaygroundPage.current.liveView &#x3D; LiveView()</span><br></pre></td></tr></table></figure>
<p>当 Playground 编译成功，你会看到这个：</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/11.Keyboard.png" align="center" />

<p>这么酷？一个 Playground 居然画出了一个音乐键盘？<br>AKKeyboardView 另外一个 AudioKit 提供的实用工具，它使这个框架真的容易使用和研究里面的功能。<br>当你按下一个键，键盘会调用 noteON 委托方法。方法的实现很简单，简单地播放了振荡器 bank。noteOff 方法则调用对应的 stop 方法。<br>点击并在键盘上滑动，你会发现它演奏出了优美的音阶。振荡器 bank 内置了 ADSR 支持。因此，一个音符的下行会和另一个音符的上升、松开和保持混在了一起，发出了令人愉悦的声音。</p>
<p>
你可能注意到了，键盘提供的音符不再以频率的方式提供，而是以 MIDINoteNumber 类型提供。如果你按住 Command 键并点击左鼠键，查看它的定义，你会看到它只是一个整型：
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public typealias MIDINoteNumber &#x3D; Int</span><br></pre></td></tr></table></figure>
MIDI 标准全称是 Musical Instrument Digital Interface（乐器数字接口）,它在乐器间进行通讯时广泛使用。 音符数字和标准键盘上的音符一一对应。play 方法的第二个参数 velocity 是另一个 MIDI 属性，用于描述一个音符的敲击力度。值越小表明敲击得越轻，会发出一个更小的声音。

<p>最后一步是将键盘设置为复音模式。在 setup 方法代码最后中加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keyboard.polyphonicMode &#x3D; true</span><br></pre></td></tr></table></figure>
<p>你会发现现在可以同时演奏多个音符了，只需要这样：</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/12.PolyphonicKeyboard.png" align="center" />

<p>……太不可思议了，C-大调。这个项目使用了 Soundpipe，代码来自于 CSound，一个起始于 1985 年的 MIT 开源项目。令人不可思议的是它可以在 Playground 中运行并添加到你的 App 中，而它竟然拥有超过 30 年的历史了！</p>
<h2 id="抽样"><a href="#抽样" class="headerlink" title="抽样"></a>抽样</h2><p>你已经学习了半天的声音合成技术了，在这个过程中你尝试用非常原始的方式制造拟真的声音：振荡器、过滤器和混合器。早在上世纪 70 年代，随着计算机处理能力和存储的增长，一种完全不同的方法出现了——声音取样——目标是制造声音的数字复制品。</p>
<p>取样是相对简单的概念，它和数字影像技术中的原理相同。自然声音是光滑的波形，取样只是在固定的时间间隔内简单地记录声波的震动：</p>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/13.Sampling.png" align="center" />

<p>在抽样过程中，有两个因素直接影响了记录的拟真度：</p>
<ul>
<li>Bit depth   - 位深: 表示一个取样器能够复制的离散振幅数。</li>
<li>Sample rate - 速率: 表示多久进行一次振幅测量，单位是 Hz。</li>
</ul>
<p>你将用另一个 Playground 来学习这些属性。<br>在 Playground 上右键，选择 New Playground Page 并创建新的 page 名为<code>Samples</code>。编辑如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line">let file &#x3D; try AKAudioFile(readFileName: &quot;climax-disco-part2.wav&quot;, baseDir: .resources)</span><br><span class="line">let player &#x3D; try AKAudioPlayer(file: file)</span><br><span class="line">player.looping &#x3D; true</span><br></pre></td></tr></table></figure>
<p>这段代码载入了一个示例音频，创建了一个声音播放器，并设置它的循环播放这个声音。<br>这个波表文件放在这个<a target="_blank" rel="noopener" href="https://koenig-media.raywenderlich.com/uploads/2016/10/climax-disco-part2.wav.zip">zip文件</a>中。解压缩这个 zip 文件，将 WAV 文件拖到 Playground 的 resources 文件夹中。</p>
<p>然后，在 Playground 文件最后继续加入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AudioKit.output &#x3D; player</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">player.play()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br></pre></td></tr></table></figure>
<p>这会将你的声频播放器传递给 AudioKit 引擎并开始播放。调大音量，注意听。<br>这个简单的例子重复播放各种声音，这些声音很难用基本的振荡器来模拟。<br>正在使用的音频有一个比较高的位深和取样率，能够产生清脆和清晰的声音。为了试验这两个参数，在创建音频播放器之后，加入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let bitcrusher &#x3D; AKBitCrusher(player)</span><br><span class="line">bitcrusher.bitDepth &#x3D; 16</span><br><span class="line">bitcrusher.sampleRate &#x3D; 40000</span><br><span class="line">AudioKit.output &#x3D; bitcrusher</span><br></pre></td></tr></table></figure>
<p>现在播放的声音就截然不同了：仍然是同一个抽样文件，但声音变得非常尖锐。<br>AKBitCrusher 是一种 AudioKit 音效，用于模拟低位深低取样率的效果。使用它，你可以制造出这种效果，就像是早期用 ZX Spectrum 或 BBC Micro 进行抽样的声音，这些电脑仅有几 Kb 的内存和处理器，比起如今的电脑来说要慢上几百万倍！</p>
<p>最后的实验，是将许多节点组合在一起，制造出立体声延迟效果。删除代码中用于创建和配置 bitcrusher 的三行代码。然后添加：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let delay &#x3D; AKDelay(player)</span><br><span class="line">delay.time &#x3D; 0.1</span><br><span class="line">delay.dryWetMix &#x3D; 1</span><br></pre></td></tr></table></figure>
<p>这会用你的抽样文件创建出大约 0.1 秒的延迟效果。干/湿混合值让你将延迟声音和未延迟的声音进行混合，设置为 1 表示只有经过延迟的声音被节点输出。<br>然后，加入代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let leftPan &#x3D; AKPanner(player, pan: -1)</span><br><span class="line">let rightPan &#x3D; AKPanner(delay, pan: 1)</span><br></pre></td></tr></table></figure>
<p>AKPanner 节点允许你将音频进行移动，左移、右移或者之间的某个地方。上述代码将延迟过的音频左移，为延迟的声音右移。<br>最后一个步骤是将两者混合在一起，并设置 AudioKit 的输出，用下面的代码替换掉原来设置 AudioKit 的输出为 bitcrusher 的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let mix &#x3D; AKMixer(leftPan, rightPan)</span><br><span class="line">AudioKit.output &#x3D; mix</span><br></pre></td></tr></table></figure>
<p>这将播放同一个文件，但在左右扬声器之间有一个非常短的延迟。<br>完整代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">import AudioKitPlaygrounds</span><br><span class="line">import AudioKit</span><br><span class="line"></span><br><span class="line">let file &#x3D; try AKAudioFile(readFileName: &quot;climax-disco-part2.wav&quot;, baseDir: .resources)</span><br><span class="line">let player &#x3D; try AKAudioPlayer(file: file)</span><br><span class="line">player.looping &#x3D; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;let bitcrusher &#x3D; AKBitCrusher(player)</span><br><span class="line">&#x2F;&#x2F;bitcrusher.bitDepth &#x3D; 16</span><br><span class="line">&#x2F;&#x2F;bitcrusher.sampleRate &#x3D; 40000</span><br><span class="line">&#x2F;&#x2F;AudioKit.output &#x3D; bitcrusher</span><br><span class="line"></span><br><span class="line">let delay &#x3D; AKDelay(player)</span><br><span class="line">delay.time &#x3D; 0.1</span><br><span class="line">delay.dryWetMix &#x3D; 1</span><br><span class="line"></span><br><span class="line">let leftPan &#x3D; AKPanner(player, pan: -1)</span><br><span class="line">let rightPan &#x3D; AKPanner(delay, pan: 1)</span><br><span class="line">let mix &#x3D; AKMixer(leftPan, rightPan)</span><br><span class="line"></span><br><span class="line">AudioKit.output &#x3D; mix</span><br><span class="line">try? AudioKit.start()</span><br><span class="line"></span><br><span class="line">player.play()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import PlaygroundSupport</span><br><span class="line"></span><br><span class="line">PlaygroundPage.current.needsIndefiniteExecution &#x3D; true</span><br></pre></td></tr></table></figure>
<img src="/images/2018-07-03-AudioKit-Tutorial-Getting-Started/14.DelayAndPan.png" align="center" />


<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在本教程中，你对“使用 AudioKit 能干什么”有了一个大致的理解了。开始探险吧——尝试一下穆格过滤，升降调、混响，或者图像均衡器的效果怎么样？<br>只需要一小点创意，你就可以制造出自己的声音、电子乐器或者游戏音效。</p>
<p>你可以下载<a href="">最终项目</a>。当然，你仍然还需要像最开始那样编译动态库，并将最终代码拖入进去即可。</p>
<p>最后，感谢 AudioKit 项目的<a target="_blank" rel="noopener" href="https://github.com/aure">Lead，Aurelius Prochazka</a>，审阅了本文。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:rockerhx@gmail.com">Andy矢倉</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://rockerhx.github.io/2018/07/03/2018-07-03-AudioKit-Tutorial-Getting-Started/">http://rockerhx.github.io/2018/07/03/2018-07-03-AudioKit-Tutorial-Getting-Started/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://rockerhx.github.io" target="_blank">Andy矢倉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Audio/">Audio</a><a class="post-meta__tags" href="/tags/AudioKit/">AudioKit</a><a class="post-meta__tags" href="/tags/Swift4/">Swift4+</a><a class="post-meta__tags" href="/tags/Xcode9/">Xcode9+</a></div><div class="post_share"><div class="social-share" data-image="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2018/08/21/2018-08-21-UIStackView-Tutorial/"><img class="prev-cover" src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">UIStackView上手教程</div></div></a></div><div class="next-post pull-right"><a href="/2018/05/02/2018-05-02-Using-Realm-Seamlessly-in-an-RxSwift-App/"><img class="next-cover" src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">RxSwift实战操作·Realm应用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2018/08/21/2018-08-21-UIStackView-Tutorial/" title="UIStackView上手教程"><img class="cover" src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&ixlib=rb-1.2.1&auto=format&fit=crop&w=1000&q=80" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 8月 21 2018</div><div class="title">UIStackView上手教程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src="https://ww1.sinaimg.cn/large/5c5c87d8gw1egzy35lsj1j20b40b40tg.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">Andy矢倉</div><div class="author-info__description">曾梦想 仗贱走天涯 看尽女人和繁华</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">39</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">51</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">18</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/rockerhx"><i class="fab fa-github"></i><span>关注我</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/rockerhx" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:rockerhx@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%80%E5%A7%8B"><span class="toc-number">1.</span> <span class="toc-text">开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%AF%E8%8D%A1%E5%99%A8%E5%92%8C%E5%A3%B0%E5%AD%A6%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">振荡器和声学基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E9%9F%B3%E5%B0%81%E5%8C%85"><span class="toc-number">3.</span> <span class="toc-text">声音封包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E9%9F%B3%E5%8F%A0%E5%8A%A0%E5%90%88%E6%88%90"><span class="toc-number">4.</span> <span class="toc-text">声音叠加合成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E9%9F%B3"><span class="toc-number">5.</span> <span class="toc-text">复音</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E6%A0%B7"><span class="toc-number">6.</span> <span class="toc-text">抽样</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AF%AD"><span class="toc-number">7.</span> <span class="toc-text">结语</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2019/05/27/2019-05-27-Building-a-NFC-Scanner-App-with-CoreNFC-in-Swift/" title="使用CoreNFC和Swift构建NFC扫描器"><img src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="使用CoreNFC和Swift构建NFC扫描器"/></a><div class="content"><a class="title" href="/2019/05/27/2019-05-27-Building-a-NFC-Scanner-App-with-CoreNFC-in-Swift/" title="使用CoreNFC和Swift构建NFC扫描器">使用CoreNFC和Swift构建NFC扫描器</a><time datetime="2019-05-27T07:30:45.000Z" title="发表于 5月 27 2019 15:30:45">5月 27 2019</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/08/21/2018-08-21-UIStackView-Tutorial/" title="UIStackView上手教程"><img src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="UIStackView上手教程"/></a><div class="content"><a class="title" href="/2018/08/21/2018-08-21-UIStackView-Tutorial/" title="UIStackView上手教程">UIStackView上手教程</a><time datetime="2018-08-21T09:36:33.000Z" title="发表于 8月 21 2018 17:36:33">8月 21 2018</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/07/03/2018-07-03-AudioKit-Tutorial-Getting-Started/" title="AudioKit 入门教程"><img src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="AudioKit 入门教程"/></a><div class="content"><a class="title" href="/2018/07/03/2018-07-03-AudioKit-Tutorial-Getting-Started/" title="AudioKit 入门教程">AudioKit 入门教程</a><time datetime="2018-07-03T15:01:11.000Z" title="发表于 7月 3 2018 23:01:11">7月 3 2018</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2018/05/02/2018-05-02-Using-Realm-Seamlessly-in-an-RxSwift-App/" title="RxSwift实战操作·Realm应用"><img src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RxSwift实战操作·Realm应用"/></a><div class="content"><a class="title" href="/2018/05/02/2018-05-02-Using-Realm-Seamlessly-in-an-RxSwift-App/" title="RxSwift实战操作·Realm应用">RxSwift实战操作·Realm应用</a><time datetime="2018-05-02T03:25:48.000Z" title="发表于 5月 2 2018 11:25:48">5月 2 2018</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2017/11/21/2017-11-21-RxSwift-Begining-2-Getting-Started-Observables/" title="RxSwift从零入手 - 入门·Observables"><img src="https://images.unsplash.com/photo-1607790201135-9655b891ab08?ixid=MXwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHw%3D&amp;ixlib=rb-1.2.1&amp;auto=format&amp;fit=crop&amp;w=1000&amp;q=80" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="RxSwift从零入手 - 入门·Observables"/></a><div class="content"><a class="title" href="/2017/11/21/2017-11-21-RxSwift-Begining-2-Getting-Started-Observables/" title="RxSwift从零入手 - 入门·Observables">RxSwift从零入手 - 入门·Observables</a><time datetime="2017-11-21T09:17:48.000Z" title="发表于 11月 21 2017 17:17:48">11月 21 2017</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2021 By Andy矢倉</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> {preloader.endLoading()})</script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></div></body></html>